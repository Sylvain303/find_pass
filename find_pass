#!/bin/bash
#
# Usage: find_pass REGEXP
#
# search into your local password-store filesystem for an entry
# matching the regexp. The regexp is filterd with sed, highlithed with grep.
# If only one entry is found, it is passed to pass show -c to be read put
# the clipboard.

main() {
    local pattern="$1"
    # remove / from pattern
    pattern=${pattern//\//.}

    local tmp=~/tmp/find_pass.tmp
    # details:
    # sed: extract result with sed, converting to pass entry format
    # tee: store in a tmp file
    # grep:Â highlithing
    find ~/.password-store/ -type f \
        | sed -n -e "/$pattern/ {
            # print the result as is
            p
            s@${HOME}/.password-store/@#  @
            s/\\.gpg\$//
            # print the pass entry format prefixed by '#  '
            p
            }" \
        | tee $tmp \
        | grep -i --color=always -- "$pattern"

    local pass=""

    # check in only one match (2 lines)
    if [[ "$(wc -l <$tmp)" -eq 2 ]]
    then
        pass="$(sed -n -e '$ s/^# \+// p' $tmp)"
    elif [[ $(grep " web/" $tmp | wc -l) -eq 1 ]]
    then
        # check if only one
        pass="$(sed -n -e '/^# \+web/ s@^# \+@@ p' $tmp)"
    fi

    if [[ ! -z "$pass" ]]
    then
        echo "reading '$pass'"
        pass show -c "$pass"
        # also display user name
        pass show "$pass" | grep --color -Ei "^(user|email)"
    fi

    rm -f $tmp
}

# sourcing code detection, if code is sourced for debug purpose,
# main is not executed.
[[ $0 != "$BASH_SOURCE" ]] && sourced=1 || sourced=0
if  [[ $sourced -eq 0 ]]
then
    # pass positional argument as is
    main "$@"
fi
