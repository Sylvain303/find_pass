#!/bin/bash
#
# Usage: find_pass REGEXP
#
# search into your local password-store filesystem for an entry
# matching the regexp. The regexp is filterd with sed, highlithed with grep.
# If only one entry is found, it is passed to pass show -c to be read put
# the clipboard.

main() {
    local pattern="$1"
    # remove / from pattern
    sed_pattern=${pattern//\//\\/}

    # use a $HOME temporary file
    local tmp=~/tmp/find_pass.tmp

    # details:
    # sed: extract result with sed, converting to pass entry format
    # tee: store in a tmp file
    # grep: highlithing
    find ~/.password-store/ -type f \
        | sed -n -e "/$sed_pattern/ {
            # print the result as is
            p
            s@${HOME}/.password-store/@#  @
            s/\\.gpg\$//
            # print the pass entry format prefixed by '#  '
            p
            }" \
        | tee $tmp \
        | grep -i --color=always -- "$pattern"

    local pass=""

    # check in only one match (2 lines)
    if [[ "$(wc -l <$tmp)" -eq 2 ]]
    then
        pass="$(sed -n -e '$ s/^# \+// p' $tmp)"
    elif [[ $(grep " web/" $tmp | wc -l) -eq 1 ]]
    then
        # check if only one
        pass="$(sed -n -e '/^# \+web/ s@^# \+@@ p' $tmp)"
    fi

    if [[ ! -z "$pass" ]]
    then
        echo "reading '$pass'"
        # pass will copy pass into clipboard (PRIMARY)
        pass show -c "$pass"
        regexp1="user|email"
        regexp2="^($regexp1|url)"
        # we copy email or user to SECONDARY clipboard (middle mouse button)
        pass show "$pass" | grep -Ei "^($regexp1)" > $tmp
        # ${var//pat/subst} substitute | to space
        for r in ${regexp1//\|/ }
        do
          echo search $r
          # GNU sed I case insensitive
          val=$(sed -n -e "/^$r/I s/^[^:]\\+: *//I p" $tmp)
          if [[ ! -z "$val" ]]
          then
            echo -e "found \033[31;1m$r\033[0m copied to SECONDARY"
            echo -n $val | xclip -selection XA_SECONDARY
            break
          fi
        done

        # also display user name, regexp2 is anchored
        pass show "$pass" | grep --color -Ei "$regexp2"
    fi

    rm -f $tmp
}

# sourcing code detection, if code is sourced for debug purpose,
# main is not executed.
[[ $0 != "$BASH_SOURCE" ]] && sourced=1 || sourced=0
if  [[ $sourced -eq 0 ]]
then
    # pass positional argument as is
    main "$@"
fi
